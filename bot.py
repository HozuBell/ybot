import discord
from discord.ext import commands
from discord import app_commands
import yt_dlp
from gtts import gTTS
import os
import asyncio
import functools
from dotenv import load_dotenv

# --- Load .env ---
load_dotenv()
TOKEN = os.getenv("TOKEN")
if not TOKEN:
    raise ValueError("‚ùå Kh√¥ng t√¨m th·∫•y TOKEN trong .env")

# Prefix h! cho bot
intents = discord.Intents.default()
intents.voice_states = True
intents.message_content = True
bot = commands.Bot(command_prefix="h!", intents=intents)

# --- YT-DLP config ---
ytdlp_opts = {
    'format': 'bestaudio/best',
    'quiet': True,
    'extract_flat': False,
    'noplaylist': False
}

queues = {}
titles = {}
play_channels = {}
now_playing_messages = {}

# --- Audio extraction (lo·∫°i b·ªè video vi ph·∫°m b·∫£n quy·ªÅn / unavailable) ---
def get_audio_source(url: str, limit=25):
    with yt_dlp.YoutubeDL(ytdlp_opts) as ydl:
        info = ydl.extract_info(url, download=False)
        urls, names = [], []
        if 'entries' in info:
            for entry in info['entries']:
                if not entry:
                    continue
                # Skip video private / deleted / unplayable
                if entry.get('is_private') or entry.get('age_limit') or entry.get('availability') in ['private', 'deleted', 'unplayable']:
                    continue
                urls.append(entry['url'])
                names.append(entry.get('title', 'Kh√¥ng r√µ'))
                if len(urls) >= limit:
                    break
        else:
            urls.append(info['url'])
            names.append(info.get('title', 'Kh√¥ng r√µ'))
        return urls, names

# --- Music Controls ---
class MusicControls(discord.ui.View):
    def __init__(self, vc: discord.VoiceClient, guild_id: int):
        super().__init__(timeout=None)
        self.vc = vc
        self.guild_id = guild_id
        self.paused = False
        self.update_buttons_label()

    def update_buttons_label(self):
        for child in self.children:
            if getattr(child, "custom_id", "") == "pause_resume":
                child.label = "‚ñ∂Ô∏è Ti·∫øp t·ª•c" if self.paused else "‚è∏Ô∏è T·∫°m d·ª´ng"

    @discord.ui.button(label="‚è∏Ô∏è T·∫°m d·ª´ng", style=discord.ButtonStyle.secondary, custom_id="pause_resume")
    async def pause_resume(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.vc.is_playing():
            self.vc.pause()
            self.paused = True
        elif self.vc.is_paused():
            self.vc.resume()
            self.paused = False
        self.update_buttons_label()
        await interaction.response.edit_message(view=self)

    @discord.ui.button(label="‚è≠Ô∏è Skip", style=discord.ButtonStyle.primary)
    async def skip(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.vc.is_playing() or self.vc.is_paused():
            self.vc.stop()
            await interaction.response.send_message("‚è≠Ô∏è B·ªè qua b√†i hi·ªán t·∫°i", ephemeral=True)
        else:
            await interaction.response.send_message("‚ö†Ô∏è Kh√¥ng c√≥ g√¨ ƒë·ªÉ skip", ephemeral=True)

    @discord.ui.button(label="‚èπÔ∏è Stop Bot", style=discord.ButtonStyle.danger)
    async def stop_bot(self, interaction: discord.Interaction, button: discord.ui.Button):
        vc = interaction.guild.voice_client
        if vc:
            queues[self.guild_id] = []
            titles[self.guild_id] = []
            await vc.disconnect()
            await interaction.response.send_message("‚èπÔ∏è Bot ƒë√£ d·ª´ng nh·∫°c v√† tho√°t.", ephemeral=True)
        else:
            await interaction.response.send_message("‚ö†Ô∏è Bot kh√¥ng ·ªü voice channel.", ephemeral=True)

# --- Embed Queue ---
def format_queue_embed(guild_id):
    queue_list = titles.get(guild_id, [])
    description = "\n".join(f"{i+1}. {t}" for i, t in enumerate(queue_list)) or "üì≠ H√†ng ch·ªù tr·ªëng."
    embed = discord.Embed(
        title="üé∂ H√†ng ch·ªù nh·∫°c",
        description=description,
        color=discord.Color.blurple()
    )
    return embed

# --- Play next song (t·ª± ƒë·ªông b·ªè video kh√¥ng ph√°t ƒë∆∞·ª£c) ---
def play_next(guild_id):
    while queues.get(guild_id):
        url = queues[guild_id].pop(0)
        title = titles[guild_id].pop(0)
        vc = discord.utils.get(bot.voice_clients, guild__id=guild_id)
        if not vc:
            continue
        try:
            source = discord.FFmpegPCMAudio(
                url,
                before_options="-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5",
                options="-vn"
            )
            def after_play(error):
                if error:
                    print(f"L·ªói khi ph√°t nh·∫°c: {error}")
                asyncio.run_coroutine_threadsafe(update_now_playing(guild_id), bot.loop)
                play_next(guild_id)
            vc.play(source, after=after_play)
            asyncio.run_coroutine_threadsafe(update_now_playing(guild_id, title), bot.loop)
            break  # N·∫øu ph√°t th√†nh c√¥ng, tho√°t v√≤ng l·∫∑p
        except Exception as e:
            print(f"‚ö†Ô∏è B·ªè b√†i {title} v√¨ kh√¥ng ph√°t ƒë∆∞·ª£c: {e}")
            continue  # Th·ª≠ b√†i ti·∫øp theo
    else:
        # Queue tr·ªëng ho·∫∑c kh√¥ng ph√°t ƒë∆∞·ª£c b√†i n√†o
        vc = discord.utils.get(bot.voice_clients, guild__id=guild_id)
        if vc and not vc.is_playing():
            asyncio.run_coroutine_threadsafe(vc.disconnect(), bot.loop)
            if guild_id in play_channels:
                asyncio.run_coroutine_threadsafe(
                    play_channels[guild_id].send("üëã Bot ƒë√£ r·ªùi k√™nh"), bot.loop
                )

# --- Update embed ---
async def update_now_playing(guild_id, title=None):
    channel = play_channels.get(guild_id)
    if not channel:
        return
    message = now_playing_messages.get(guild_id)
    embed = format_queue_embed(guild_id)
    if title:
        embed.title = f"üé∂ ƒêang ph√°t: {title}"
    if message:
        try:
            await message.edit(embed=embed)
        except discord.NotFound:
            msg = await channel.send(embed=embed, view=MusicControls(discord.utils.get(bot.voice_clients, guild__id=guild_id), guild_id))
            now_playing_messages[guild_id] = msg
    else:
        msg = await channel.send(embed=embed, view=MusicControls(discord.utils.get(bot.voice_clients, guild__id=guild_id), guild_id))
        now_playing_messages[guild_id] = msg

# --- Bot ready ---
@bot.event
async def on_ready():
    print(f"‚úÖ Bot ƒë√£ ƒëƒÉng nh·∫≠p: {bot.user}")
    for guild in bot.guilds:
        try:
            await bot.tree.sync(guild=discord.Object(id=guild.id))
            print(f"üîó Commands synced cho guild: {guild.name}")
        except Exception as e:
            print(f"‚ö†Ô∏è L·ªói sync cho {guild.name}: {e}")
    try:
        await bot.tree.sync()
        print("üîó Commands global sync complete")
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói global sync: {e}")

# --- Play music command ---
@bot.tree.command(name="nhac", description="Ph√°t nh·∫°c ho·∫∑c playlist t·ª´ YouTube")
@app_commands.describe(url="Link YouTube (video ho·∫∑c playlist)")
async def nhac(interaction: discord.Interaction, url: str):
    await interaction.response.defer(ephemeral=True)
    if not interaction.user.voice:
        await interaction.followup.send("‚ùå B·∫°n ph·∫£i ·ªü trong voice channel tr∆∞·ªõc.", ephemeral=True)
        return
    vc = interaction.guild.voice_client
    if vc is None:
        vc = await interaction.user.voice.channel.connect()
    try:
        play_channels[interaction.guild.id] = interaction.channel
        urls, names = get_audio_source(url)
        urls = urls[:25]
        names = names[:25]
        queues.setdefault(interaction.guild.id, []).extend(urls)
        titles.setdefault(interaction.guild.id, []).extend(names)
        if not vc.is_playing():
            play_next(interaction.guild.id)
        await interaction.followup.send(f"üé∂ ƒê√£ th√™m {len(urls)} b√†i v√†o h√†ng ch·ªù.", ephemeral=True)
    except Exception as e:
        await interaction.followup.send(f"‚ùå L·ªói khi ph√°t nh·∫°c: {e}", ephemeral=True)

# --- TTS chung ---
async def tts_play(interaction_or_ctx, text: str, is_slash=False):
    guild = interaction_or_ctx.guild
    author = interaction_or_ctx.user if is_slash else interaction_or_ctx.author
    channel_send = interaction_or_ctx.channel
    if not author.voice or not author.voice.channel:
        msg = "‚ùå B·∫°n c·∫ßn v√†o voice channel tr∆∞·ªõc."
        if is_slash:
            await interaction_or_ctx.followup.send(msg, ephemeral=True)
        else:
            await channel_send.send(msg, delete_after=10)
        return

    vc = guild.voice_client
    if vc is None:
        vc = await author.voice.channel.connect()
    
    try:
        filename = f"tts_{guild.id}.mp3"
        tts = gTTS(text=text, lang="vi")
        tts.save(filename)

        if vc.is_playing():
            vc.stop()

        def after_play(error, file=filename):
            if os.path.exists(file):
                try:
                    os.remove(file)
                except Exception as e:
                    print(f"L·ªói x√≥a file {file}: {e}")

        source = discord.FFmpegPCMAudio(filename)
        vc.play(source, after=functools.partial(after_play))

        msg = f"üó£ Bot ƒëang n√≥i: **{text}**"
        if is_slash:
            await interaction_or_ctx.followup.send(msg)
        else:
            await channel_send.send(msg, delete_after=15)

    except Exception as e:
        msg = f"‚ùå L·ªói khi chuy·ªÉn vƒÉn b·∫£n th√†nh gi·ªçng n√≥i: {e}"
        if is_slash:
            await interaction_or_ctx.followup.send(msg)
        else:
            await channel_send.send(msg, delete_after=10)

# --- Slash command /noichuyen ---
@bot.tree.command(name="noichuyen", description="Chuy·ªÉn vƒÉn b·∫£n th√†nh gi·ªçng n√≥i (ti·∫øng Vi·ªát)")
async def noichuyen(interaction: discord.Interaction, text: str):
    await interaction.response.defer()
    await tts_play(interaction, text, is_slash=True)

# --- Prefix command h!say ---
@bot.command(name="say")
async def h_say(ctx: commands.Context, *, text: str):
    await tts_play(ctx, text)

# --- Prefix command h!leave ---
@bot.command(name="leave")
async def h_leave(ctx: commands.Context):
    vc = ctx.guild.voice_client
    if vc:
        queues[ctx.guild.id] = []
        titles[ctx.guild.id] = []
        await vc.disconnect()
        await ctx.send("üëã Bot ƒë√£ r·ªùi kh·ªèi voice channel", delete_after=10)
    else:
        await ctx.send("‚ö†Ô∏è Bot hi·ªán kh√¥ng ·ªü trong voice channel.", delete_after=10)

# --- Auto leave ---
@bot.event
async def on_voice_state_update(member, before, after):
    for vc in bot.voice_clients:
        if len(vc.channel.members) == 1 and vc.channel.members[0] == bot.user:
            await vc.disconnect()
            if vc.guild.id in play_channels:
                await play_channels[vc.guild.id].send("üëã M·ªçi ng∆∞·ªùi ƒë√£ r·ªùi k√™nh, bot s·∫Ω tho√°t.")

# --- Run bot ---
bot.run(TOKEN)
